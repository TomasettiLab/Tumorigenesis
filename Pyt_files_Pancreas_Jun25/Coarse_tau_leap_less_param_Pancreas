#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 28 23:01:11 2018

@author: klahouel
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 28 22:23:16 2018

@author: klahouel
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Sep  2 22:36:12 2018

@author: klahouel
"""
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jun 19 17:36:52 2017

@author: klahouel
"""
# -*- coding: utf-8 -*-
"""
Created on Thu Oct 20 23:22:01 2016

@author: kamel
"""
# Two Carrying capacities one for symmetric division and one for asymetric division
# -*- coding: utf-8 -*-
#cancerMutations2.py
#Feedback Model
#Last Updated: 4/26/2015, Added feature to print out population of individual type 3 clones

import os
from os import path
import argparse
import numpy as np
import scipy as sp
import numpy.matlib as npmat
import time
import multiprocessing as mp
import warnings
from itertools import product
import sklearn.gaussian_process as gp
import sklearn.gaussian_process.kernels as kn
#import pyDOE as pyl
import datetime
warnings.filterwarnings("ignore")






class tissue:
    #parameters:
    #N: wild type population size
    #ngrp: number of mutation groups
    #pmute: probability of mutation
    #rho0: slope parameter for asymetric differentiation
    #delta: update time step for simulation
    
    #pgrp: conditional probability of groups given mutation. If
    #      length=1,all groups are equi-likely 
    #T: maximum lifetime (in weeks)
    #t3Threshold: number of mutations in last type for cancer to
    #             occur.
    #epsilon0: radius of lowest to highest rate intervals for normal
    #          population homeostasis
    #cang: angio-genesis effect (increased resource)
    #capp: apoptosis effect (death rate decrease)
    #cpro: proliferation effect (division increase)
    
    
    
   
    
    
    
    
    
    def __init__(self, N = 1, dcell = 1e9, ngrp=18, pmute =5*1e-6,pmuteLOH=1e-5,pmutesuperLOH=10**(-3),  pgrp = [1], alpha=1., capp=1.5 ,cappInter=1., targ_size=10.,targ_size1h=100., delta=0.5, 
                 T=52*75+36,lastTime=40,deltaMute=1*1e-6,deltaOnc1=0.001,psym=0.0275,pasymdiff=0.95,psymdiff=0.05-0.0275,deltapsym=1.7e-3,PowerRate=0.7,TargetDiv=0.07,mult=16,powersize=10):
        
        self.Tsind=np.append([0,2,3],np.arange(10,18))
        self.Oncind=np.append([1],np.arange(4,10)) 
        self.PathwaysCF=[{0,1,2},{3}]
        self.PathwaysCS=[{4,5,6},{7},{8,9},{10}]
        self.PathwaysGM=[{11},{12},{13},{14},{15},{16},{17}]   
        self.N = int(N)
        self.crypt_size = 1
        self.nb_crypt = self.N /self.crypt_size  
        
        
        self.dcell = int(dcell)
        
        self.ngrp = ngrp
        #self.pchange = pchange
        self.nmut = 0
        
        
        self.alpha = alpha
        self.capp = capp
        self.cappInter=cappInter
        self.sigma_app = float(targ_size)*((self.alpha+1)*targ_size + (self.alpha-1)*self.crypt_size)/((self.alpha-1)*targ_size + (self.alpha+1)*self.crypt_size)
        
        self.lastTime=lastTime
        
        
        self.delta = delta
        self.deltapsym=deltapsym
        if len(pgrp) == 1:
            self.pgrp = np.append(np.ones(ngrp-1)/(ngrp-1),0)
            self.pgrp[4] *=1
            self.pgrp =self.pgrp/self.pgrp.sum()
        else:
            self.pgrp = pgrp
            
        self.pmute = pmute
        self.pmuteLOH=pmuteLOH
        self.pmutesuperLOH=pmutesuperLOH
        self.deltaMute=deltaMute
        self.T = T
        self.PowerRate=PowerRate
        self.TargetDiv=TargetDiv
        self.groupsize = np.array([N] + [0]*self.ngrp, dtype=int)
        self.kchange = .1
        self.maxAge = 500
        self.deltaOnc1=deltaOnc1
        
        self.psym=psym
        self.pasymdiff=pasymdiff
        self.psymdiff=psymdiff
        self.age=0
        self.mult=mult
        self.powersize=powersize
        
        
       
        
        
   

    #basic division/death rate with total population feedback
    def hfun(self, n, a, s, ep,flag=1):
        #alpha=(75*52+36-self.age)/(75*52+36-20*52-36)
        alpha=self.age-(20*52+36)
        #Mult=alpha+(1-alpha)/2
        Lam0=(75*52-20*52)/np.log(2)
        Mult=np.exp(-alpha/Lam0)
        #a=np.log(1+((s-1)*float(n)/float(s)))/np.log(s)
        #u = float(7)/(3.5+a)
        if (float(10*n)/(np.sqrt(1)*10**self.powersize*s))<1 and (self.age<=20*52+36):
           #u =self.mult*np.exp(np.log(4/self.mult)/((52*20)**(1))*(20*52)**(1))*(3*np.exp(1)*0.45/3.5*np.exp(-1/(1-(float(10*n)/(np.sqrt(1)*10**self.powersize*s))**(self.PowerRate)))+self.TargetDiv)
           u=np.exp(1)*(1.75-self.TargetDiv)*np.exp(-1/(1-(float(10*n)/(np.sqrt(1)*10**self.powersize*s))**(self.PowerRate)))+self.TargetDiv
        elif (float(10*n)/(10**self.powersize*s))<1 and (self.age>20*52+36):
           #u=4*(3*np.exp(1)*0.45/3.5*np.exp(-1/(1-(float(10*n)/(np.sqrt(1)*10**self.powersize*s))**(self.PowerRate)))+self.TargetDiv)  
           u=(Mult**(flag))*np.exp(1)*(1.75-self.TargetDiv)*np.exp(-1/(1-(float(10*n)/(np.sqrt(1)*10**self.powersize*s))**(self.PowerRate)))+(Mult**flag)*self.TargetDiv
        else:
           u=1*self.TargetDiv*(self.age<52*20+36)+(Mult**(flag))*self.TargetDiv*(self.age>=52*20+36)
        
        
            #a * self.crypt_size + b* float(n))/(self.crypt_size + float(n))
            # s is the target size
            # n is 
        return u/60
    
    
        
    

    #
    def CleanList(self,L):
       ind=0
       l=len(L)
       
       for i in range(l):
           if ((L[ind].sum())==L[ind][0,0,0]):
               L.pop(ind)
           else:
               ind +=1
       return L
    
    
    def getPreRateGeneric(self):
    
        Rates=np.zeros((3,3,2,4))
        AsymRates=np.zeros((3,3,2))
        #deltaProb=0.01/2
        #self.psymdiff=self.psym-deltaProb
        psym0=self.psym
        psymdiff0=self.psymdiff
        pasymdiff0=self.pasymdiff       
        tauDiv0=1
        tauDeathc=(psym0-psymdiff0)
        pmute0=self.pmute
        
        for i,j,k in product(range(3),range(3),range(2)):
            psym=psym0+i*self.deltapsym
            psymdiff=psymdiff0-(1*(i==1)+(2)*(i==2))*self.deltapsym
            pasymdiff=pasymdiff0
            tauDiv=tauDiv0*(self.capp**(1*(j==1)+(2)*(j==2)))
            pmute=pmute0+k*self.deltaMute            
            Rates[i,j,k,0]=tauDeathc
            Rates[i,j,k,1]=tauDiv*psymdiff    
            Rates[i,j,k,2]=tauDiv*psym*(1-pmute)
            Rates[i,j,k,3]=tauDiv*pasymdiff*float(pmute)/2+tauDiv*psym*float(pmute)
            AsymRates[i,j,k]=tauDiv*pasymdiff
            
           
        self.Rates=self.delta*Rates
        self.AsymRates=self.delta*AsymRates
        return self.delta*Rates
    
    

        
    
    def GenericReactions(self):
        
     GenericRates=np.zeros((3,3,2,5))
      
     for i,j,k in product(range(3),range(3),range(2)):
          GenericRates[i,j,k,0]=self.Rates[i,j,k,0]+self.Rates[i,j,k,1]
          GenericRates[i,j,k,1]=self.Rates[i,j,k,2]
          GenericRates[i,j,k,2]=self.Rates[i,j,k,3]*(3*10**(-3))*(1/(1+i))
          GenericRates[i,j,k,3]=self.Rates[i,j,k,3]*(11*10**(-3))*(1/(1+j))       
          GenericRates[i,j,k,4]=self.Rates[i,j,k,3]*(4*10**(-3))        
                    
                    
            
            
                
            
            
           
     self.ReactionsRate=GenericRates
     return GenericRates
 
    def TypesIndices(self):
        Type1=[[],[],[]]
        Type2=[[],[],[]]
        Type3=[[],[],[]]
        for i,j,k in product(range(3),range(3),range(2)):
            if (i+j+k)==1:
                Type1[0].append(i)
                Type1[1].append(j)
                Type1[2].append(k)
            elif  (i+j+k)==2:
                Type2[0].append(i)
                Type2[1].append(j)
                Type2[2].append(k)
            elif (i+j+k)>=3:
                Type3[0].append(i)
                Type3[1].append(j)
                Type3[2].append(k)
        self.IndType1=Type1
        self.IndType2=Type2
        self.IndType3=Type3
            
                
            
        
    def Likelihoods(self,D,Y):
        l=np.log(sp.stats.norm.cdf(Y*D))
        dl=Y*sp.stats.norm.pdf(D)/sp.stats.norm.cdf(Y*D)
        ddl=-sp.stats.norm.pdf(D)**2/sp.stats.norm.cdf(Y*D)**2-Y*D*sp.stats.norm.pdf(D)/sp.stats.norm.cdf(Y*D)
        return l, dl, np.diag(ddl)
    
#    
    def MaxLikelihood(self,K,Y,tol):
        n=np.shape(Y)[0]
        D=np.zeros(n)
        #DOld=np.ones(n)
        Lst=[]
        grads=[]
        values=[]
        gr=np.ones(n)
        Ds=[]
        k=0
        while (np.linalg.norm(gr)>tol) and k<1000:
            k +=1
            #DOld=D
            Lik=self.Likelihoods(D,Y)
            W=-Lik[2]
            WHalf=sp.linalg.sqrtm(W)
            L=np.linalg.cholesky(np.diag(np.ones(n))+WHalf @ K @ WHalf)
            b=W @ D+Lik[1]
            d=np.linalg.solve(L,WHalf @ K @ b)   
            a=b- WHalf @ (np.linalg.solve(L.transpose(),d))
            gr=Lik[1]-np.linalg.solve(K+0.0000001*np.diag(np.ones(n)),D)
            grads.append(np.linalg.norm(gr))
            D=np.dot(K,a)                      
            values.append(-1/2*np.dot(a,D)+np.sum(Lik[0]))
            Lst.append(-1/2*np.dot(a,D)+np.sum(Lik[0])-np.sum(np.diag(L)))
            Ds.append(D)
        return D,Lst,grads,values, Ds
    
    
    def EPApprox(self,K,Y,tol):
        n=np.shape(Y)[0]
        nuTilde=np.zeros(n)
        tauTilde=np.zeros(n)
        nuOld=np.ones(n)
        tauOld=np.ones(n)
        Sigma=np.copy(K)
        mu=np.zeros(n)
        k=0
        while ((np.linalg.norm(nuTilde-nuOld,np.inf)+np.linalg.norm(tauTilde-tauOld,np.inf))>tol) and k<50:
               nuOld=np.copy(nuTilde)
               tauOld=np.copy(tauTilde)
               k +=1
               
               for i in range(n):
                   tauMinusI=Sigma[i,i]**(-2)-tauTilde[i]
                   nuMinusI=Sigma[i,i]**(-2)*mu[i]-tauTilde[i]
                   muMinusI=nuMinusI/tauMinusI
                   sigmaMinusI2=1/tauMinusI
                   zI=Y[i]*muMinusI/np.sqrt(1+sigmaMinusI2)
                   #ZhatI=sp.stats.norm.cdf(zI)
                   muHatI=muMinusI+Y[i]*sigmaMinusI2*sp.stats.norm.pdf(zI)/(sp.stats.norm.cdf(zI)*np.sqrt(1+sigmaMinusI2))
                   sigmaHatI2=sigmaMinusI2-(zI+sp.stats.norm.pdf(zI)/sp.stats.norm.cdf(zI))*(sigmaMinusI2**2*sp.stats.norm.pdf(zI)/((1+sigmaMinusI2)*sp.stats.norm.cdf(zI)))
                   deltaTauTilde=1/sigmaHatI2-tauMinusI-tauTilde[i]
                   tauTilde[i]=tauTilde[i]+deltaTauTilde
                   #print(deltaTauTilde)
                   nuTilde[i]=(1/sigmaHatI2)*muHatI-nuMinusI
                   sI=Sigma[:,i].reshape((n,1))
                   Sigma -=(1/((1/deltaTauTilde)+Sigma[i,i]))*(sI @ sI.transpose())
                   mu= Sigma @ nuTilde
               print(((np.linalg.norm(nuTilde-nuOld,np.inf)+np.linalg.norm(tauTilde-tauOld,np.inf))))
               STilde=np.diag(tauTilde)
               STildeHalf=sp.linalg.sqrtm(STilde)
               L=np.linalg.cholesky(np.diag(np.ones(n))+STildeHalf @ K @ STildeHalf)
               V=np.linalg.solve(L.transpose(),STildeHalf @ K)
               Sigma=K-((V.transpose()) @ V)
               mu= Sigma @ nuTilde
        return nuTilde,tauTilde,k
               
                   
              
        




#    
#    def MaxLikelihood(self,K,Y,tol):
#        n=np.shape(Y)[0]
#        D=np.zeros(n)
#        #DOld=np.ones(n)
#        Lst=[]
#        grads=[]
#        values=[]
#        grad=np.ones(n)
#        Ds=[]
#        k=0
#        while (np.linalg.norm(grad) > tol) and k<1000:
#            k +=1
#            #DOld=D
#            Lik=self.Likelihoods(D,Y)
#            grad=Lik[1]-np.linalg.solve(K,D)
#            grads.append(np.linalg.norm(grad))
#            #print(np.linalg.det(K))
#            Hessian=(Lik[2]-np.linalg.inv(K))
#            #print(np.linalg.det(Hessian))
#            D -= np.linalg.solve(Hessian,grad)
#            values.append(np.sum(Lik[0])-1/2*np.dot(D.transpose(),np.linalg.solve(K,D)))
#            #print(D)
#            Ds.append(D)
#        return D,Lst,grads,values, Ds
    
#    def MaxLikelihoodGradient(self,K,Y,tol):
#        n=np.shape(Y)[0]
#        D=np.zeros(n)
#        grads=[]
#        values=[]
#        grad=np.ones(n)
#        Ds=[]
#        k=0
#        while (np.linalg.norm(grad)>tol) and k<1000:
#              k +=1
#              Lik=self.Likelihoods(D,Y)
#              grad=Lik[1]-np.linalg.solve(K,D)
#              grads.append(np.linalg.norm(grad))
#              D +=(1/k)*grad
#              values.append(np.sum(Lik[0])-1/2*np.dot(D.transpose(),np.linalg.solve(K,D)))
#              Ds.append(D)
#        return D,grads,values, Ds
              
              
    
    
    
    
    
    def PosteriorMeanVariance(self,K,Y,tol,x,X,C,l):  
        d=np.shape(x)[0]           
        N=np.shape(Y)[0]
        #K=np.zeros
        #K=np.zeros((N,N))
        Kstar=np.zeros(N)
        Kstarprime=np.zeros((N,d))
#        for i,j in product(range(N),range(N)):
#            K[i,j]=C**2*np.exp(-1/(2*l**2)*(np.linalg.norm(X[i,:]-X[j,:]))**2)
        DHat=self.MaxLikelihood(K+0.0*np.diag(np.ones(N)),Y,tol)         
        for i in range(N):
            Kstar[i]=C**2*np.exp(-1/(2*l**2)*(np.linalg.norm(X[i,:]-x))**2) 
        for i,j in product(range(N),range(d)):
            Kstarprime[i,j]=-1/(l**2)*Kstar[i]*(x[j]-X[i,j])                          
        kStar=C**2
        Lik=self.Likelihoods(DHat[0],Y)
        PMean=np.dot(Kstar,Lik[1])
        PmeanPrime=np.dot(Kstarprime.transpose(),Lik[1])
        W=-Lik[2]
        L=np.linalg.cholesky(np.diag(np.ones(N))+np.sqrt(W) @ K @ np.sqrt(W))
        #A=np.linalg.solve((K-np.linalg.inv(Lik[2])),Kstar)
        v=np.linalg.solve(L,np.sqrt(W) @ Kstar)
        vPrime=np.linalg.solve(L, np.sqrt(W) @ Kstarprime)
        PVariance=kStar-np.dot(v,v)
        PVariancePrime=-2* (vPrime.transpose() @ v)
        ObjectivePrime=sp.stats.norm.pdf(PMean/np.sqrt(1+PVariance))*(PmeanPrime*(1+PVariance)**(-1/2)-1/2*PMean*PVariancePrime*(1+PVariance)**(-3/2))
        return PMean,PVariance,sp.stats.norm.cdf(PMean/np.sqrt(1+PVariance)), ObjectivePrime,K
    
    
    
    
    
    
    
    def FitGradient(self,L_K,Y,tol,X,C,l,Const,LearningRate,iterations):
        N=np.shape(Y)[0]
        d=np.shape(Y)[1]
        x=np.copy(X[N-2,:])
        #xold=np.ones(d)
        Jacobian=np.zeros((d,d))
        values=np.zeros(d)
        k=0
        while  k<iterations:
               k +=1
               #print(k)
               print((values**2).sum())
               #xold=np.copy(x)
               for i in range(d):
                   Post=self.PosteriorMeanVariance(L_K[i],Y[:,i],tol,x,X,C[i],l[i])
                   values[i]=Post[2]-Const[i]
                   Jacobian[i,:]=Post[3]
                   #print (Jacobian,np.linalg.det(Jacobian))
               gradient=np.sum(np.diag(values) @ Jacobian ,axis=0)    
               x -=(2*LearningRate)*gradient
               
               x[0]=max(0.0501,min(x[0],0.06))/0.0501
               x[1]=max(1,min(x[1],2))
               x[2]=max(1e-3,min(x[2],2e-3))*1e3
        return x, values,gradient
            
    
    def ChooseBestParam(self,Y,tol,X,X_new,C,l,Const):
        d=np.shape(Y)[1]           
        N=np.shape(Y)[0]
        Perf=np.zeros(N)
        for i in range(N):
            for j in range(d):
                Post=self.PosteriorMeanVariance(Y[:,j],tol,X_new[i,:],X,C[j],l[j])
                Perf[i] +=np.abs(Post[2]-Const[j])
        index=np.argmin(Perf)
        return index,X_new[index,:],Perf[index]
                
        
        
            
    
    
    
            
        
        
    
        
    
  
    
    
    
        
        
    
    
    
    
    
   
             
         
         
         




    # computes probability of group hit given mutation    
    # computes probability of group hit given mutation    
    
        
    
    def CancerTest(self,Tabmutations):
        
        Type1=np.any(Tabmutations[self.IndType1[0],self.IndType1[1],self.IndType1[2],:]>100,axis=0)
        Type2=np.any(Tabmutations[self.IndType2[0],self.IndType2[1],self.IndType2[2],:]>100,axis=0)
        Type3=np.any(Tabmutations[self.IndType3[0],self.IndType3[1],self.IndType3[2],:]>100,axis=0)
        
        #self.Plastic=np.logical_and(self.CrTot>3*10**8,self.CrTot/self.CrSizes<10)
        #WinType=np.logical_and(Type3,self.Plastic)      
        return np.any(Type3),Type3,Type2,Type1
        
    
    
    def TestCancerClonal(self):
        self.TypesIndices()
        Time=time.time()
        t=0
        self.age=20*52
        self.getPreRateGeneric()
        self.GenericReactions()
        self.age=0
        L=set()
        TabMutations=np.zeros((3,3,2,int(1.1*10**7)))
        TabDifferentiated=np.zeros((6*60,int(1.1*10**7)))
        TabHistory=5000*np.ones((3,int(1.1*10**7)))
        Tmutations=np.zeros((2,2,2,2))
        self.Diagnostic=False
        self.status=False
        self.CrTot45=np.array([10**11, 10**11])
        self.Nold=0
        self.N=0
        while t<self.T and not(self.status):
              self.Nold=self.N
              #print(t)
            
              
#              if t==52*20:
#
#                 self.pmute=10**(-5)
#
#                 self.getPreRateGeneric()
#
#                 self.GenericReactions()
#
#
#
#              if t==52*40:
#
#                 self.pmute=10**(-6)
#
#                 self.getPreRateGeneric()
#
#                 self.GenericReactions()
            
              
              
              self.Diagnostic,self.Type3,self.Type2,self.Type1=self.CancerTest(TabMutations[:,:,:,list(L)])
              
#              if self.Diagnostic:
#                      self.TabMutations=TabMutations[:,:,:,list(L)]
#                      self.CrSizes=np.sum(self.TabMutations,axis=(0,1,2))+self.crypt_size                                  
#                      self.TabDifferentiated=TabDifferentiated[:,list(L)]
#                      self.DiffCrSizes=np.dot(2**np.arange(7),self.TabDifferentiated)+(self.crypt_size)*(2**7-1)
#                      self.CrTot=self.DiffCrSizes+self.CrSizes
#                      self.TabHistory=TabHistory[:,list(L)]
#                      
#                      self.Plastic=np.logical_and(self.CrTot>3*10**8,self.CrTot/self.CrSizes<10)
#                      self.status=np.any(np.logical_and(self.CancerTest(self.TabMutations)[1],self.Plastic))
              
              
              IndType1=np.where(self.Type1)[0]
              IndType2=np.where(self.Type2)[0]
              IndType3=np.where(self.Type3)[0]
              
              if len(IndType1)>0:
                 
                 TabHistory[0,np.array(list(L))[IndType1]]=np.minimum(TabHistory[0,np.array(list(L))[IndType1]],t)
                 
              if len(IndType2)>0:
                 TabHistory[1,np.array(list(L))[IndType2]]=np.minimum(TabHistory[1,np.array(list(L))[IndType2]],t)
                 
              if len(IndType3)>0:
                 TabHistory[2,np.array(list(L))[IndType3]]=np.minimum(TabHistory[2,np.array(list(L))[IndType3]],t)
                 
              if t<36:
                self.N=np.ceil((1+10*1388*2*t)/.1)
              elif (t>=36) and (t<20*52):
                self.N=np.ceil((1+10*1388*72+10*463*2*(t-36))/.1)
              else:
                self.N=np.ceil((1+10*1388*72+10*463*2*(52*20-36))/.1)
              
                
              
              self.nb_crypt=np.ceil(self.N/10)
              self.nb_cryptOld=np.ceil(self.Nold/10)
              #print(self.nb_crypt-self.nb_cryptOld)
              
              self.crypt_size=int(np.ceil(self.N/self.nb_crypt))
              

              #print(int(self.nb_crypt-self.nb_cryptOld))
              if t<=20*52:
                 self.IndInheritence=np.intersect1d(np.random.randint(0,self.nb_cryptOld+1,int(self.nb_crypt-self.nb_cryptOld)),np.array(list(L)))
                 if len(self.IndInheritence)>0:
                    #print(len(self.IndInheritence))
                    TabMutations[:,:,:,np.arange(int(self.nb_cryptOld),int(self.nb_cryptOld)+len(self.IndInheritence))]=TabMutations[:,:,:,self.IndInheritence]
                    L=L.union(np.arange(int(self.nb_cryptOld),int(self.nb_cryptOld)+len(self.IndInheritence)))
                 
                          
              
              
              #print(t)
              if t<50*52:
              
              
                 N=np.random.poisson(self.N*self.hfun(10,1,10,1)*self.ReactionsRate[0,0,0,2]*np.array([1,11/3,4/3]))
              
              
                 A0=np.random.randint(0,self.nb_crypt+1,N[0])
                 A1=np.random.randint(0,self.nb_crypt+1,N[1])
                 A2=np.random.randint(0,self.nb_crypt+1,N[2])
              
              
              
                 unique0,count0=np.unique(A0,return_counts=True)
                 unique1,count1=np.unique(A1,return_counts=True)
                 unique2,count2=np.unique(A2,return_counts=True)
               
                 TabMutations[1,0,0,unique0] +=count0
                 TabMutations[0,1,0,unique1] +=count1 
                 TabMutations[0,0,1,unique2] +=count2
              
                 L =L.union(set(unique0),set(unique1),set(unique2))
              
              #print(L)
              
              
              
              
              
              if len(L)>0:
                  
                  
                  
                  
                  
                  ind=list(L)
                  
                  Tmutations=np.copy(TabMutations[:,:,:,(ind)])
                  
                  TDifferentiated=np.copy(TabDifferentiated[:,ind])
                  
                  TDifferentiated=np.roll(TDifferentiated,1,axis=0)
                  
                  
                  
                  CrSizes=np.sum(Tmutations,axis=(0,1,2))
                  
                  self.CrSizes=CrSizes
                  
                  #print(CrSizes)
                  DivRates=np.zeros(len(L))
                  NumberDiff=np.dot(2**(np.floor(np.arange(6*60)/60)),TabDifferentiated[:,list(L)])
                  
                  for k in range(len(L)):
                      
                      DivRates[k]=self.hfun(CrSizes[k]+NumberDiff[k],1,10,1)   
                  
                  
                  
                  
                    
                  
                      
                  ReactionsMutants0=np.tile(np.reshape(self.ReactionsRate[:,:,:,2],(3,3,2,1)),(1,1,1,len(L)))*Tmutations
                                           
                  ReactionsMutants1=np.tile(np.reshape(self.ReactionsRate[:,:,:,3],(3,3,2,1)),(1,1,1,len(L)))*Tmutations
                                           
                  ReactionsMutants2=np.tile(np.reshape(self.ReactionsRate[:,:,:,4],(3,3,2,1)),(1,1,1,len(L)))*Tmutations
                                           
                  DivRatesTable=np.tile(np.reshape(DivRates,(1,1,1,len(L))),(3,3,2,1))
                  
                  ReactionsMutants0 *=DivRatesTable
                  
                  ReactionsMutants1 *=DivRatesTable
                  
                  ReactionsMutants2 *=DivRatesTable
                  
                  ReactionsDeath1=Tmutations*self.hfun(10,1,10,1,flag=1)*np.tile(np.reshape(self.Rates[:,:,:,0],(3,3,2,1)),(1,1,1,len(L)))
                  ReactionsDeath2=Tmutations*DivRatesTable*np.tile(np.reshape(self.Rates[:,:,:,1],(3,3,2,1)),(1,1,1,len(L)))
                  
                  ReactionsReplicate=Tmutations*DivRatesTable*np.tile(np.reshape(self.Rates[:,:,:,2],(3,3,2,1)),(1,1,1,len(L)))
                  
                  #print("d1 is: {0}".format((np.tile(np.reshape(self.Rates[:,:,:,0],(3,3,2,1)),(1,1,1,len(L)))+DivRatesTable*np.tile(np.reshape(self.Rates[:,:,:,1],(3,3,2,1)),(1,1,1,len(L)))).mean()))
                  
                  #print("d2 is: {0}".format((DivRatesTable*np.tile(np.reshape(self.Rates[:,:,:,2],(3,3,2,1)),(1,1,1,len(L)))).mean()))
                  
                  ReactionsDiff1=Tmutations*DivRatesTable*np.tile(np.reshape(self.AsymRates,(3,3,2,1)),(1,1,1,len(L)))
                  
                  #print(np.max(ReactionsDiff1))
                  
                  
                  PoissonReactionsMutants0=np.random.poisson(ReactionsMutants0)
                  
                  PoissonReactionsMutants1=np.random.poisson(ReactionsMutants1)
                  
                  PoissonReactionsMutants2=np.random.poisson(ReactionsMutants2)
                  
                  PoissonReactionsDeath1=np.random.poisson(ReactionsDeath1)
                  PoissonReactionsDeath2=np.random.poisson(ReactionsDeath2)
                  PoissonReactionsDeath=PoissonReactionsDeath1+PoissonReactionsDeath2
                  
                  
                  
                  
                  
                  PoissonReactionsReplicate=np.random.poisson(ReactionsReplicate)
                  
                  
                  
                  #print(PoissonReactionsReplicate.mean())
                  
                  PoissonReactionsDiff=np.random.poisson(ReactionsDiff1)+2*PoissonReactionsDeath2
                                                        
                  TDifferentiated[0,:]=np.sum(PoissonReactionsDiff,axis=(0,1,2))                                     
                  
                  
                  MutantsUpdate0=np.roll(PoissonReactionsMutants0,1,axis=0)
                  MutantsUpdate0[1,:,:,:] +=MutantsUpdate0[0,:,:,:]
                  MutantsUpdate0[0,:,:,:] = 0
                                
                  MutantsUpdate1=np.roll(PoissonReactionsMutants1,1,axis=1)
                  MutantsUpdate1[:,1,:,:] +=MutantsUpdate1[:,0,:,:]
                  MutantsUpdate1[:,0,:,:] = 0
                                
                  MutantsUpdate2=np.roll(PoissonReactionsMutants2,1,axis=2)
                  MutantsUpdate2[:,:,1,:] +=MutantsUpdate2[:,:,0,:]
                  MutantsUpdate2[:,:,0,:] = 0
                  
                  Tmutations +=(MutantsUpdate0+MutantsUpdate1+MutantsUpdate2+PoissonReactionsReplicate-PoissonReactionsDeath)
                  #print(Tmutations.shape)
                  Tmutations=np.maximum(Tmutations,np.zeros((3,3,2,len(L))))
                  #print(Tmutations.shape)
                  TabMutations[:,:,:,(ind)]=np.copy(Tmutations)
                  TabDifferentiated[:,ind]=np.copy(TDifferentiated)        
                  ind=np.array(ind)            
                  ind=np.copy(ind[np.sum(Tmutations,axis=(0,1,2))>0])
                  
                  
                  
                  L=set(ind)
                  
                  if t==52*50:             
                     self.TabMutations45=TabMutations[:,:,:,list(L)]
                     self.CrSizes45=np.sum(self.TabMutations45,axis=(0,1,2))+self.crypt_size                                  
                     self.TabDifferentiated45=TabDifferentiated[:,list(L)]
                     self.DiffCrSizes45=np.dot(2**(np.floor(np.arange(6*60)/60)),self.TabDifferentiated45)+(self.crypt_size)*(2**6-1)
                     self.CrTot45=self.DiffCrSizes45+self.CrSizes45
                  
                  
                  
                  
                  
                  
              if self.Diagnostic:
                      self.TabMutations=TabMutations[:,:,:,list(L)]
                      self.CrSizes=np.sum(self.TabMutations,axis=(0,1,2))+self.crypt_size                                  
                      self.TabDifferentiated=TabDifferentiated[:,list(L)]
                      self.DiffCrSizes=np.dot(2**(np.floor(np.arange(6*60)/60)),self.TabDifferentiated)+(self.crypt_size)*(2**6-1)
                      self.CrTot=self.DiffCrSizes+self.CrSizes
                      self.TabHistory=TabHistory[:,list(L)]
                      
                      self.Plastic=np.logical_and(self.CrTot>1.25*10**8,self.CrTot/self.CrSizes<5000)
                      self.status=np.any(np.logical_and(self.CancerTest(self.TabMutations)[1],self.Plastic))
              t +=self.delta
              self.age=t
                  
                      #self.status=(self.status) or (self.CrTot.max()>10**11)
                      
                  #print(np.nonzero(np.sum(Tmutations,axis=(0,1,2)))[0].shape)
                

                  
                  
                  
                
                  
              
              
              
              
              
              
              
              
              
              
              
                  
                
                     
              
                
           
                  
        self.Diagnostic,self.Type3,self.Type2,self.Type1=self.CancerTest(TabMutations[:,:,:,list(L)])
        
        
        self.TabMutations=TabMutations[:,:,:,list(L)]
        self.CrSizes=np.sum(self.TabMutations,axis=(0,1,2))+self.crypt_size                                  
        self.TabDifferentiated=TabDifferentiated[:,list(L)]
        self.DiffCrSizes=np.dot(2**(np.floor(np.arange(6*60)/60)),self.TabDifferentiated)+(self.crypt_size)*(2**6-1)
        self.CrTot=self.DiffCrSizes+self.CrSizes
        self.TabHistory=TabHistory[:,list(L)]                 
        self.L=L
        #print (np.min(self.CrTot/self.CrSizes))
              
        if self.Diagnostic:
                      self.TabMutations=TabMutations[:,:,:,list(L)]
                      self.CrSizes=np.sum(self.TabMutations,axis=(0,1,2))+self.crypt_size                                  
                      self.TabDifferentiated=TabDifferentiated[:,list(L)]
                      self.DiffCrSizes=np.dot(2**(np.floor(np.arange(6*60)/60)),self.TabDifferentiated)+(self.crypt_size)*(2**6-1)
                      self.CrTot=self.DiffCrSizes+self.CrSizes
                      self.TabHistory=TabHistory[:,list(L)]
                      
                      self.Plastic=np.logical_and(self.CrTot>1.25*10**8,self.CrTot/self.CrSizes<5000)
                      self.status=np.any(np.logical_and(self.CancerTest(self.TabMutations)[1],self.Plastic))
                  
        
        
#        self.Plastic=np.logical_and(self.CrTot>3*10**8,self.CrTot/self.CrSizes<10)
        self.ExitTime=t
        print (time.time()-Time ) 
        print(t)
#        if (self.CrSizes.shape[0])>0:
#            print (self.CancerTest(self.TabMutations)[0])
#            print ((self.CrSizes).max())
#        self.status=np.any(np.logical_and(self.CancerTest(self.TabMutations)[1],self.Plastic))
        #return L
ExitTimes=list()
L=list() 
C=list() 
C1=list()
C45=list()
TH=list()
TM=list()
Ratio=list()
NPolyps1=list()
NPolyps145=list()
NPolyps2=list()
NPolyps245=list()
NPolyps3=list()
NPolyps345=list()









#Done #Checked

#X_Star123=[ 1.002  ,        1.2    ,     1.22460554 , 1.11921576 , 2.03411581  ,1.83136433,
 # 1.52046482]

# 1 -> gp 1 gp2 gp2 ; 1-> gp1 gp2 gp1 16-> gp 1 gp1 gp2


#Done #Checked

#X_Star132=[ 1.03     ,     1.30964407,  1.78118668 , 0.4       ,  2.58081304  ,1.56276176,
#  1.4470213 ]

# 2 -> group1 group2 group1 1-> gp1 gp2 gp2 12-> gp1 gp1 gp2




#Done #Checked

#X_Star213=[ 1.01393599 , 1.23827834 , 1.50694946 , 1.25662646 , 0.70129281 , 0.9838521,
# 1.53857839] 0.017

# 1-> gp1 gp2 gp2  20 -> gp1 gp1 gp2

            
            
            
            
            
#Done   # Checked       
            
#X_Star231=[ 1.09    ,      1.2    ,     2.    ,      1.44103079 , 0.97336333 , 1.91292988 ,
 # 1.34454887] 0.009

# 5-> gp1 gp1 gp2 2->gp1 gp2 gp2 7->gp2 gp1 gp2

            
            
#Done  #Checked        

#X_Star312=[ [ 1.04953762 , 1.46890205 , 0.3   ,      0.4    ,     2.54505949  ,1.90741193,
# 1.62169359]] 0.022

# 4-> gp2 gp2 gp3  14->gp2 gp2 gp1

            
            
#Done #Checked

#X_Star321=np.array([ 1. , 1.20269377  ,1.7759515 ,  1.25814219 , 0.20915281 , 0.93730077,
#  1.50042693]) 0.026

# 15 -> gp1 gp1 gp2  3-> gp1 gp2 gp1























#Scenarios for DeltaTimings: From smallest to largest for example [1,3,2] means first time shorter than third time shorter than second time.
#Scen=np.array([3,2,1])
#
#
#
#
#
#
##Preparing space filling
#
#
#LowerBounds=np.tile(np.array([1.0009,0.019,0.0009/0.03,0.19]),(100,1))
#
#Lengths=np.tile(np.array([1.21,5.01,0.11/0.03,2.01])-np.array([1.0009,0.301,0.0009/0.03,0.19]),(100,1))
#
#LatinHyper=LowerBounds+Lengths*pyl.lhs(4,samples=100)
#
##Number of iterations for fitting the parameters.
#Nindividuals0=1000
#
##[ 1.          1.14943737  1.19202268  1.          2.66616078  1.51636497
##  1.57142857]
#
#cases=0 
#kernel=1**2*kn.Matern(length_scale=np.ones(4),nu=1.5)
#
#datasets0=np.zeros((Nindividuals0,10))
#datasets0[0,:]=np.array([1.001,0.02,0.001/0.03,0.2,-1,1,-1,-1,-1,-1])
#datasets0[1,:]=np.array([1.2,4,0.1/0.03,2,1,-1,1,1,1,1])
#Const=np.array([0.95 ,0.99,0.03,0.40,0.02,0.03])
#x_Star=[np.array([1.2     ,    1.31      ,    0.16666667  ,5]),1]
#x_explore=np.zeros(4)
#x_explore[0]=np.random.uniform(1.001,1.2)
#x_explore[1]=np.random.uniform(0.02e-3,5e-3)*1e3
#x_explore[3]=np.random.uniform(0.2,2)  
#x_Explore=[x_explore,1]
#x_Star=x_Explore
#datasets0[2:,8]=-np.ones(Nindividuals0-2)
#datasets0[2:,9]=-np.ones(Nindividuals0-2)
#
#
#
#
#
#
#
#
#for  i in np.arange(2,Nindividuals0):
#    
#       if i<100:
#          datasets0[i,0:4]=LatinHyper[i,:]
#          
#       
#       else:
#         
#        if np.mod(i,2)==0:
#          datasets0[i,0]=x_Explore[0][0]
#          datasets0[i,1]=x_Explore[0][1]
#          datasets0[i,2]=x_Explore[0][2]
#          datasets0[i,3]=x_Explore[0][3]
#           
#
#        else:
#          datasets0[i,0]=x_Star[0][0]
#          datasets0[i,1]=x_Star[0][1]
#          datasets0[i,2]=x_Star[0][2]
#          datasets0[i,3]=x_Star[0][3]
#          
#       
#           
#       print(i)
#       t1=tissue(capp=datasets0[i,0],psym=0.0050,psymdiff=0,deltapsym=datasets0[i,1]*1e-3,PowerRate=datasets0[i,3],TargetDiv=datasets0[i,2]*0.03,mult=1,powersize=9)    
#       t1.TestCancerClonal()
#       datasets0[i,4]=2*int(t1.CrTot.max()>(3*10**8))-1
#       datasets0[i,5]=2*int(t1.CrTot.max()<(10**10))-1
#       datasets0[i,6]=2*int(t1.status)-1
#       datasets0[i,7]=2*int(t1.CrTot45.max()>(3*10**8))-1 
#       
#                
#                
#                
#        
#       print ("the minimum ratio is {0}: ".format((t1.CrTot[np.where(t1.CrTot==max(t1.CrTot))]/t1.CrSizes[np.where(t1.CrTot==max(t1.CrTot))])))
#       L.append(t1.status)
#       C.append((t1.CrTot).max())
#       print("The size of the largest crypt is {0}: ".format(np.log((t1.CrTot).max())/np.log(10)))
#       C1.append(t1.CrSizes.max())
#       print("The size of the largest crypt at 45 is {0}: ".format(np.log((t1.CrTot45).max())/np.log(10)))
#       C45.append(t1.CrTot45.max())
#       if t1.status:
#          
#          print("CASE number:{0}".format(cases+1))
#          cases +=1
#          HittingTimes=np.where(np.logical_and(t1.Type3,t1.Plastic))[0]
#          TH.append(t1.TabHistory[:,HittingTimes])
#          TM.append(t1.TabMutations[:,:,:,HittingTimes])  
#          THistory=t1.TabHistory[:,HittingTimes]
#          THistory=THistory[:,0]
#          DeltaTiming=np.array([THistory[0],THistory[1]-THistory[0],THistory[2]-THistory[1]])
#          datasets0[i,8]=2*int(((t1.TabMutations[:,:,:,HittingTimes])[1,1,0][0]) > ((t1.TabMutations[:,:,:,HittingTimes])[2,0,0][0]))-1
#          datasets0[i,9]=2*((DeltaTiming[Scen[0]-1]<DeltaTiming[Scen[1]-1]) and (DeltaTiming[Scen[1]-1]<DeltaTiming[Scen[2]-1]))-1
#       X0=np.copy(datasets0[0:(i+1),0:4])
#       Y0=np.copy(datasets0[0:(i+1),4:10])
#       g1=gp.GaussianProcessClassifier(kernel)
#       g1.fit(X0,Y0[:,0])
#       Cs1=np.sqrt(np.exp(g1.kernel_.theta[0]))
#       l1=(np.exp(g1.kernel_.theta[1]))
#       g2=gp.GaussianProcessClassifier(kernel)
#       g2.fit(X0,Y0[:,1])
#       Cs2=np.sqrt(np.exp(g2.kernel_.theta[0]))
#       l2=(np.exp(g2.kernel_.theta[1]))
#       g3=gp.GaussianProcessClassifier(kernel)
#       g3.fit(X0,Y0[:,2])
#       Cs3=np.sqrt(np.exp(g3.kernel_.theta[0]))
#       l3=(np.exp(g3.kernel_.theta[1]))
#       g4=gp.GaussianProcessClassifier(kernel)
#       g4.fit(X0,Y0[:,3])
#       Cs4=np.sqrt(np.exp(g4.kernel_.theta[0]))
#       l4=(np.exp(g4.kernel_.theta[1]))
#       g5=gp.GaussianProcessClassifier(kernel)
#       g5.fit(X0,Y0[:,4])
#       Cs5=np.sqrt(np.exp(g5.kernel_.theta[0]))
#       l5=(np.exp(g5.kernel_.theta[1])) 
#       g6=gp.GaussianProcessClassifier(kernel)
#       g6.fit(X0,Y0[:,5])
#       Cs6=np.sqrt(np.exp(g6.kernel_.theta[0]))
#       l6=(np.exp(g5.kernel_.theta[1]))
#       
#       def Hellinger_Squared(p,q):
#           return (np.linalg.norm(np.sqrt(p)-np.sqrt(q)))**2
#       
#       def objective_exploration(x,*kwargs):  
#           eps=10**(-5)
#           return min(0,-sp.stats.entropy([g1.predict_proba(x)[0][1]+eps,1-g1.predict_proba(x)[0][1]-eps])-sp.stats.entropy([g2.predict_proba(x)[0][1]+eps,1-g2.predict_proba(x)[0][1]-eps])-sp.stats.entropy([g3.predict_proba(x)[0][1]+eps,1-g3.predict_proba(x)[0][1]-eps])-sp.stats.entropy([g4.predict_proba(x)[0][1]+eps,1-g4.predict_proba(x)[0][1]-eps]))
#       
#       def objective(x,*kwargs):
#           
#           y1=g1.predict_proba(x)[0][1]
#           y2=g2.predict_proba(x)[0][1]
#           y3=g3.predict_proba(x)[0][1]
#           y4=g4.predict_proba(x)[0][1]
#           y5=g5.predict_proba(x)[0][1]
#           y6=g6.predict_proba(x)[0][1]    
#           #p=np.array([y1,y2,y3,y4,y5,y6])
#           #d=Hellinger_Squared(p,Const)    
#           return 1/(Const[0]**1)*(Const[0]-y1)**2+1/(Const[1]**1)*(Const[1]-y2)**2+1/(Const[2]**1)*(Const[2]-y3)**2+1/(Const[3]**1)*(Const[3]-y4)**2+1/((1-Const[0])**2)*(Const[0]-y1)**2+1/((1-Const[1])**1)*(Const[1]-y2)**2+1/((1-Const[2])**1)*(Const[2]-y3)**2+1/((1-Const[3])**1)*(Const[3]-y4)**2
#           #d1=min(sp.stats.entropy([Const[0],1-Const[0]],[y1,1-y1])+sp.stats.entropy([Const[1],1-Const[1]],[y2,1-y2])+sp.stats.entropy([Const[2],1-Const[2]],[y3,1-y3])+sp.stats.entropy([Const[3],1-Const[3]],[y4,1-y4])+sp.stats.entropy([Const[4],1-Const[4]],[y5,1-y5])+sp.stats.entropy([Const[5],1-Const[5]],[y6,1-y6]),1000)
#           #d2=min(sp.stats.entropy([y1,1-y1],[Const[0],1-Const[0]])+sp.stats.entropy([y2,1-y2],[Const[1],1-Const[1]])+sp.stats.entropy([y3,1-y3],[Const[2],1-Const[2]])+sp.stats.entropy([y4,1-y4],[Const[3],1-Const[3]])+sp.stats.entropy([y5,1-y5],[Const[4],1-Const[4]])+sp.stats.entropy([y6,1-y6],[Const[5],1-Const[5]]),1000)
#           #return d
#           #np.abs(Const[0]-y1)+np.abs(Const[1]-y2)+np.abs(Const[2]-y3)+np.abs(Const[3]-y4)+np.abs(Const[4]-y5)+np.abs(Const[5]-y6)
#       x_Star=sp.optimize.fmin_tnc(objective,9/10*np.copy(x_Star[0])+1/10*np.copy(x_Explore[0]),approx_grad=True,bounds=[(1.001,1.2),(0.02,5),(0.001/0.03,0.1/0.03),(0.2,2)],epsilon=1e-5)
#       InitialPoint=np.zeros(7)
#       InitialPoint[0]=np.random.uniform(0.0501,0.0501)/0.0501
#       InitialPoint[1]=np.random.uniform(1.001,1.2)
#       InitialPoint[2]=np.random.uniform(0.02e-3,5e-3)*1e3
#       InitialPoint[3]=np.random.uniform(0.5,0.5)/0.5
#       InitialPoint[4]=np.random.uniform(0.001,0.1)/0.03
#       InitialPoint[5]=np.random.uniform(0.2,2)  
#       InitialPoint[6]=np.random.uniform(11,11)/7
#       x_Explore=sp.optimize.fmin_tnc(objective_exploration,InitialPoint[np.array([1,2,4,5])],approx_grad=True,bounds=[(1.001,1.2),(0.02,5),(0.001/0.03,0.1/0.03),(0.2,2)],epsilon=1e-3)
#
#       print("The parameters are: {0}".format(x_Star[0]))
#       print("The predicted probability for constraint 1 is {0}.\n The predicted probability for constraint 2 is {1} \n.The predicted probability for constraint 3 is {2} \n.The predicted probability for constraint 4 is {3} \n.The predicted probability for constraint 5 is {4} \n.".format(g1.predict_proba(x_Star[0]),g2.predict_proba(x_Star[0]),g3.predict_proba(x_Star[0]),g4.predict_proba(x_Star[0]),g6.predict_proba(x_Star[0])))
#       
#       print("The parameters for exp are: {0}".format(x_Explore[0]))
#       print("The predicted probability for exp  constraint 1 is {0}.\n The predicted probability for constraint 2 is {1} \n.The predicted probability for constraint 3 is {2} \n.The predicted probability for constraint 4 is {3} \n.The predicted probability for constraint 5 is {4} \n.".format(g1.predict_proba(x_Explore[0]),g2.predict_proba(x_Explore[0]),g3.predict_proba(x_Explore[0]),g4.predict_proba(x_Explore[0]),g6.predict_proba(x_Explore[0])))
#       
#       
#print("The parameters are: {0}".format(x_Star[0]))
#print("The predicted probability for constraint 1 is {0}.\n The predicted probability for constraint 2 is {1} \n.The predicted probability for constraint 3 is {2} \n.The predicted probability for constraint 4 is {3} \n.The predicted probability for constraint 5 is {4} \n.".format(g1.predict_proba(x_Star[0]),g2.predict_proba(x_Star[0]),g3.predict_proba(x_Star[0]),g4.predict_proba(x_Star[0]),g6.predict_proba(x_Star[0])))
##   
#

#
##










 
###
###
####
###
##
##
##
##
##
##
##
##
##
##
#




#

#XSTAR=np.array([ 1.15376108 , 1.2      ,   1.5       ,  1.8     ,    1.043968  ,  0.43877002,
#  1.30498665])

    
    
#XSTAR=np.array([ 1. , 1.20269377  ,1.7759515 ,  1.25814219 , 0.20915281 , 0.93730077,
#  10] )    
#    
#    
#    
#XSTAR=np.array([ 1.20121987  ,1.51684216 , 0.16666667 , 1.35239762] )  
#XSTAR=np.array([ 1.23321987  ,1.5144216 , 0.16666667 , 1.35239762] )






























 
#XSTAR=np.array([ 1.001034    ,   1.2126093  , 6.520495134 , 0.7259945])
#XSTAR=np.array([ 2.95*1.001034    ,   1.2126093  , 6.520495134 , 0.7259945])
XSTAR=np.array([2.7 * 1.36555829  , 1.3318825  , 10.37307922 ,  1.54758523])

XSTAR=np.array([3*1.35595122  , 1.86287641 , 13.78221431 ,  0.46843411])


##    
##    
TH_oneHit=list()
TH_twoHits=list()  
Label_oneHit=list()
Label_twoHits=list()



#
#
#
#
#

Nindividuals=1000
cases=0

for i in range(Nindividuals):
    print(i)
    #t1=tissue(capp=XSTAR[0],psym=0.0525+0.3,pasymdiff=1-0.3525-0.0475,psymdiff=0.0475,deltapsym=XSTAR[1]*1e-3,PowerRate=XSTAR[3],TargetDiv=XSTAR[2]*0.03,mult=1,powersize=9)    

    t1=tissue(capp=XSTAR[0],psym=0.0525*60/(0.0525*60+1-0.0525-0.0475+0.0475*60),pasymdiff=(1-0.0525-0.0475)/(0.0525*60+1-0.0525-0.0475+0.0475*60),psymdiff=0.0475*60/(0.0525*60+1-0.0525-0.0475+0.0475*60),deltapsym=XSTAR[1]*1e-3,PowerRate=XSTAR[3],TargetDiv=XSTAR[2]*0.03,mult=1,powersize=9.)    
    t1.TestCancerClonal()
    ExitTimes.append(t1.ExitTime)
    if len(t1.CrSizes)>0:
       print ("the minimum ratio is : {0} ".format(t1.CrTot[np.where(t1.CrSizes==max(t1.CrSizes))]/t1.CrSizes[np.where(t1.CrSizes==max(t1.CrSizes))]))
       Ratio.append(t1.CrTot[np.where(t1.CrSizes==max(t1.CrSizes))]/t1.CrSizes[np.where(t1.CrSizes==max(t1.CrSizes))])
       L.append(t1.status)
       C.append((t1.CrTot).max())
       print("The size of the largest crypt is : {0} ".format(np.log((t1.CrTot).max())/np.log(10)))
       C1.append(t1.CrSizes.max())
       print("The size of the largest crypt at 50 is : {0} ".format(np.log((t1.CrTot45).max())/np.log(10)))
       C45.append(t1.CrTot45.max())
    
    
       NPolyps1.append(sum(t1.CrTot>1.25*10**8))
       print("The number of polyps is {0}: ".format(sum(t1.CrTot>1.25*10**8)))
       NPolyps145.append(sum(t1.CrTot45>1.25*10**8))
       print("The number of polyps at age 50  is : {0} ".format(sum(t1.CrTot45>1.25*10**8)))
       NPolyps2.append(sum(t1.CrTot>10**9))
       print("The number of polyps is {0}: ".format(sum(t1.CrTot>10**9)))
       NPolyps245.append(sum(t1.CrTot45>10**9))
       print("The number of polyps at age 50  is : {0} ".format(sum(t1.CrTot45>10**9)))
       NPolyps3.append(sum(t1.CrTot>3*10**9))
       print("The number of polyps is {0}: ".format(sum(t1.CrTot>3*10**9)))
       NPolyps345.append(sum(t1.CrTot45>3*10**9))
       print("The number of polyps at age 50  is : {0} ".format(sum(t1.CrTot45>3*10**9)))
    
    
       HittingTimes1=np.where(np.logical_and(t1.Type1,t1.CrTot>1.25*10**8))[0]
       if HittingTimes1 !=[]:
          TH_oneHit.append(t1.TabHistory[:,HittingTimes1][:,0])
          Label_oneHit.append(int(t1.status))
       
       
       HittingTimes2=np.where(np.logical_and(t1.Type2,t1.CrTot>1.25*10**8))[0]
       if HittingTimes2 !=[]:
          TH_twoHits.append(t1.TabHistory[:,HittingTimes2][:,0])
          Label_twoHits.append(int(t1.status))
    
    
    
       if t1.status:
          
          print("CASE number:{0}".format(cases+1))
          cases +=1
          HittingTimes=np.where(np.logical_and(t1.Type3,t1.Plastic))[0]
          TH.append(t1.TabHistory[:,HittingTimes])
          TM.append(t1.TabMutations[:,:,:,HittingTimes]) 
    #del t1
    
#
    
print(TH)   
Ratio=np.array(Ratio)

Times1=np.zeros(len(TH))
Times2=np.zeros(len(TH))
Times3=np.zeros(len(TH))



for i in range(len(TH)):
    Times1[i]=TH[i][0][0]/52
    Times2[i]=(TH[i][1][0]-TH[i][0][0])/52
    Times3[i]=(TH[i][2][0]-TH[i][1][0])/52
    

#
#
#
#
#
for i in range(len(TH)):
    print(TM[i][1,1,1])
####
####
####
####
####
####
####5-> gp2 gp2 1-> gp2 gp3
####
####
####
####
####
####
####
###
###
###
###
####
###
#
np.save('C321'+str((datetime.datetime.now())),C)
np.save('C45321'+str((datetime.datetime.now())),C45)
np.save('Times1321'+str((datetime.datetime.now())),Times1)
np.save('Times2321'+str((datetime.datetime.now())),Times2)
np.save('Times3321'+str((datetime.datetime.now())),Times3)
np.save('TH321'+str((datetime.datetime.now())),TH)
np.save('Ratio321'+str((datetime.datetime.now())),Ratio)
np.save('Ratio321'+str((datetime.datetime.now())),Ratio)
np.save('TM321'+str((datetime.datetime.now())),TM)
np.save('ExitTimes'+str((datetime.datetime.now())),ExitTimes)
#
#
#
#
#
#
#
#
#
#
#          
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


















#[ 1.1         1.30086594  0.29963551  2.        ]

#[ 1.14158859  1.31330595  0.16666667  1.99987017]   
 
#[ 1.17712559  1.31615075  0.16666667  2.        ]

#[ 1.1         1.41036179  0.16841541  1.66458125]

#[ 1.1905768   1.52854422  0.16666667  1.36935198]


#[ 1.17722616  1.51661392  0.16666667  1.3887164 ]


# [ 1.18449666  1.53774963  0.16666667  1.33878823]      

                  
# [ 1.18319191  1.54031174  0.16666667  1.33221049]                 
                
              
# [ 1.19505643  1.5281337   0.16666667  1.35517707]                
                         
                         
#[ 1.20121987  1.50684216  0.16666667  1.35239762]                         
                         
                         
                     
                      
        
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

   

    
   
        
    
   
    
    
    

            
                
            
            
        
            
        
#[ 1.19257806  3.9292769   3.2751733   1.89276488]     
        
        
    
    
        
        
        
        
        
        
        
        
    
    
                   
               
    
    
        
        
   
    
    
    
            
            
#[ 1.1         1.05254673  3.33333333  7.38583586]         
        
        

        

        
        
        
        
        
        
        
        
    
    
        
#[ 1.001       2.01019257  0.36779679  0.83282049]                       
                    
                    
                    
                    

                
        
        
        
#[ 1.14977152  1.9476714   1.30000007  1.15691423]   
        
        
        
        
        
        
        
#[ 1.18419415  3.34079257  2.97865159  0.67711078]        

    
    

#[ 1.16060618  2.95856658  1.30610329  1.57306405]


#21

#The parameters are: [ 1.08228666  4.33953745  1.51503425  1.22984835]
#[ 1.03869064  4.396206    0.55419048  0.94408322]
#Expinteresting[ 1.00100071  4.55744505  0.03333333  0.58884109]
#[ 1.14437168  4.223768    0.90123847  1.09788437]
#The parameters are: [ 1.17755737  4.2200468   3.08158363  1.45684836]
#[ 1.08777776  4.37441322  1.03251819  1.11373257]
#[ 1.11634543  4.58044972  1.42014116  1.2049519 ]
#[ 1.11354636  4.48043366  1.28412816  1.24262412]
#[ 1.02492345  4.24573099  1.08954863  1.2110275 ]
#[ 1.05700267  4.57498301  1.47434066  1.20135591]
#[ 1.01        1.87001767  3.73706111  0.24007528]